**Κωστάκης Ελευθέριος-Παναγιώτης, AM: 2741, Μουζάκι 21.7.2020,**
**e-mail: cs02741@uoi.gr, 6ο έτος.**

# ΕΙΣΑΓΩΓΗ

Δούλεψα στο περιβάλλον του jupyter notebook με έδοση της **Python 3.7.7** και έκδοση της **Tensorflow 1.14.0**, επίσης χρειάστηκαν περισσότερα εργαλεία για την
ολοκλήρωση της άσκησης, όπως το sklearn για τον PCA και τον KMeans αλλά και τα matplotlib, numpy κ.α.

Αρχικά έκανα `git clone` τον κατάλογο deeplab και έπειτα τροποποίησα τον κώδικα του demo του καταλόγου για τα ερωτήματα που έπρεπε να υλοποιήσω.
Το deeplab είναι ένα ισχυρό εργαλείο το οποίο χρησιμεύει στην σημασιολογική κατάτμηση της εικόνας. Πιο συγκεκριμένα χρησιμοποιεί κάποια σύνολα δεδομένων στα οποία
έχει εκπαιδευτεί ώστε να αναπτύξει γενικευτική ικανότητα και να δίνει σωστά αποτελέσματα σε όλα τα "άγνωστα" για αυτό παραδείγματα. Η default επιλογή στην άσκηση
μας είναι το σύνολο δεδομένων `PASCAL VOC 2021` το οποίο περιέχει 21 ετικέτες(κλάσεις), ουσιαστηκά μπορεί να ξεχωρίσει 21 διαφορετικά αντικείμενα κατά την σημασιολογική κατάτμηση. (Υπάρχουν και άλλα σύνολα δεδομένων όπως το ADE20k και το Cityscapes.)
Η αρχιτεκτονική υλοποίησης που χρησιμοποιήθηκε για την άσκηση είναι το MobileNetv2. (Επίσης το deeplab μπορέι να λειτουργίσει με διαφορετικές άλλες αρχιτεκτονικές όπως το MobileNetv2, Xception κ.α.)

### ΕΡΩΤΗΜΑ Α
Στο πρώτο ερώτημα για το αρχείο jupyter notebook [![a.ipynb](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/a/a.ipynb)](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/a/a.ipynb), έγινε κατάτμηση για πέντε διαφορετικές εικόνες όπως φαίνεται και στο αρχείο, όλες μαζί με ένα for-loop. Αυτό που χρειάστηκε
ήταν να αλλαχτεί το path των φωτογραφιών ώστε να δείχνει σε φωτογραφίες μέσα από τον υπολογιστή.

Όσον αφορά το αρχείο [![a.py](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/a/a.py)](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/a/a.py) τρέχει με εντολή τύπου:

```
python3 a.py <input filename> <output filename>
```
όπου εμφανίζεται στον χρήστη και αποθηκεύεται η εικόνα του αποτέλεσματος της κατάτμησης στο αρχείο `<output filename>`.

Ένα παράδειγμα:

```
python3 a.py image1.jpg segmented1.jpg
```
έχει ως αποτέλεσμα:
![segmented](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/a/segmented1.jpg)

Οι αλλαγές που έγιναν για αυτό το αρχείο ήταν να βάλω σε σχόλιο την συνάρτηση `vis_segmentation(resized_im, seg_map)` και απλά να βγάλω εξωτερικά τις εντολές που μας ενδιαφέρουν από αυτήν και να σώσω το figure.

(Αυτή η συνάρτηση είναι υπεύθυνη για την οπτικοποίηση της εικόνας, η βασική λειτουργία έχει γίνει στην `resized_im, seg_map = MODEL.run(original_im)`.)


### ΕΡΩΤΗΜΑ Β

Σε αυτό το ερώτημα αφού έχει βρεθεί ένα ενδιάμεσο στρώμα της συνέλιξης μειώνεται η διάσταστη σου σε 3 κανάλια ώστε να μπορέσει να γίνει η οπτικοποίηση. Αρχικά η σκέψη που πρέπει να γίνει είναι: "Πως θα βρούμε ένα ενδιάμεσο στρώμα;". Ψάχνοντας στον κώδικα του demo ξανά, παρατήρησα ότι στην κλάση `DeepLabModel` αρχικοποιείται ο γράφος των τενσόρων. Έτσι με τον παρακάτω κώδικα (ειναι σε σχόλια στο [![b.ipynb](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/b/b.ipynb)](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/b/b.ipynb).) μας εμφανίζει όλες τις λειτουργίες που εκτελούνται κατά την κατάτμηση. Έτσι αντιλήφθηκα πως υπάρχουν 16 ενδιάμεσα στρώματα συνέλιξης, και έπειτα αρκεί να αλλάξουμε τον τένσορα της εξόδου από `SemanticPredictions:0` σε `MobilenetV2/expanded_conv_8/output:0` (Η επιλογή της εξόδου του 8ου ενδιάμεσου στρώματος είναι τυχαίο γεγονός.)

Στην συνέχεια μπήκε σε σχόλια η `vis_segmentation()` διότι δεν γίνεται να οπτικοποιηθεί ένα ενδιάμεσο στρώμα με παραπάνω από τρία κανάλια (διάσταση). Συγκεκριμένα το συγκεκριμένο ενδιάμεσο επίπεδο έχει διαστάσεις `(65, 65, 64)`. (64 κανάλια που πρέπει να γίνουν 3.)

Έτσι δημιουργήθηκε η PCA() η οποία είναι υπεύθυνη για να "ρίξει" την διάσταση των χαρακτηριστηκών μας σε τρία, ώστε να μπορέσουμε να την οπτικοποιήσουμε. Αυτό έγινε σύμφωνα με τον κώδικα που υπάρχει στο [![pca.ipynb](https://github.com/dip-course/pca_on_deepfeatures/blob/master/pca.ipynb)](https://github.com/dip-course/pca_on_deepfeatures/blob/master/pca.ipynb), εφόσον ο χάρτης κατάτμησης του ενδιάμεσου επιπέδου έχει ήδη αποθηκευτεί `np.save('deepfeats.npy', seg_map)`. Έτσι μετά την μείωση διάστασης έγινε δυνατή η οπτικοποίηση του ενδιάμεσου στρώματος.

Όσον αφορά το αρχείο [![b.py](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/b/b.py)](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/b/b.py), έγιναν τα παράπανω βήματα για την επιλογή του ενδιάμεσου επιπέδου, με την διαφορά ότι όπως και για το ερώτημα α), το αρχείο τρέχει με εισαγωγή στο τερματικό τύπου, μετά από τις κατάλληλες αλλαγές:
```
python3 b.py <input filename> <output filename>
```
ένα αντίστοιχο παράδειγμα:
Ένα παράδειγμα:

```
python3 b.py image4.jpg intermediate4.jpg
```
βγάζει στον χρήστη την εικόνα του ενδιάμεσου επιπέδου, εφόσον έγινε μείωση της διάστασης προφανώς. 
Για το παράδειγμά μας παίρνουμε αποτέλεσμα:

![intermediate4.jpg](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/b/intermediate4.jpg)

Όπως παρατηρούμε όντως, αντικείμενα παρόμοιας σημασιολογίας αντιστοιχούν σε παρόμοιο χρώμα.


### ΕΡΩΤΗΜΑ Γ

Αυτό το ερώτημα αποτελεί συνέχεια του ακριβώς προηγούμενου ερωτήματος. Εφόσον κάνουμε την μείωση διαστάσεων από 64 σε **8**, έπειτα το δύσκολο μέρος του ζητούμενου έγκειται στο ερώτημα "Τι χρειάζεται ο kmeans για να μου δώσει "σωστά αποτελέσματα";". Ο kmeans για ομαδοποίηση είναι μορφής "χωρίς επίβλεψης". Αυτό σημαίνει ότι ανάλογα με τα τμήματα-γείτονες ομαδοποιεί τα δεδομένα, όμως δεν γνωρίζει από πριν την κατηγορία των δεδομένων(pixels). Για την συνέχεια του ερωτήματος μας, εφόσον έγινε μείωση διάστασης σε `(65,65,8)` το πρόβλημα είναι ότι ο kmeans για να δουλέψει πρέπει να πάρει ως είσοδο το πολύ διδιάστατα δεδομένα. Πράγμα που σημαίνει ότι έπρεπε να γίνει ένα "τρικ" ώστε να μην χάσει κάποια από τα βαθιά χαρακτηριστηκά του ενώ παράλληλα από "3D" να γίνει "2Δ". Όπως έγινε και τον κώδικα του PCA, έτσι και εδώ η ιδέα είναι να κάνουμε ένα `reshape` ώστε να μην χαθεί καμία πληρφορία αλλά να "συμμαζέψουμε" τα "βαθιά" χαρακτηριστηκά. Σε αυτό το κομμάτι μας βοηθάει πάρα πού η Python η οποία με την εντολή `reshape(-1,...)` μας βρίσκει μόνη της μία διάσταση "συμβατή" με την αρχική διάσταση ώστε να μετασχηματιστεί ο πίνακας μας χωρίς να αλλάζει ουσιαστηκά τα δεδομένα. Με λίγα λόγια συγχωνεύει την διάσταση `(65,65,8)` σε `(65x65,8)`.

H kmeans υλοποιήθηκε με το εργαλείο **scikit-learn** σύμφωνα με την υπόδειξη. Η fit() αρχικά εκτέλεσε τον αλγόριθμο kmeans για `k=2` και έπειτα η predict χρησιμοποιήθηκε για τις προβλέψεις για εύρεση ομάδων που ανήκει κάθε πρότυπο του συνόλου δεδομένων μας. Τελικά οι κατηγορίες για κάθε πρότυπο μας από τα συνολικά `65x65=4225` είναι αποθηκευμένες στο `y_pred` όπως φαίνεται στον κώδικα. 
(αλλιώς μπορούμε να πούμε κατευθείαν ότι `labels=clustering.labels_` για να δούμε σε ποιά από τις δυο κατηγορίες ανήκει το πρότυπο μας, είναι σε σχόλια)

Τώρα θα πρέπει να επαναφέρουμε τα αποτελέσματα-κατηγορίες στην αρχική μορφή της εικόνας ενδιάμεσου επιπέδου `(65,65)` χωρίς να μας ενδιαφέρουν τα κανάλια εφόσουν οι τιμές είναι αποκλειστηκά `0` ή `1`. Αυτό εύκολα υλοποιείται με την εντολή `np.reshape(y_pred, (65,65))`. Το αρχείο [![c.ipynb](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/c/c.ipynb)](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/c/c.ipynb) όπως σε κάθε ερώτημα παρουσιάζει τα αποτελέσματα της κάθε εικόνας, μετά τον kmeans. Παρατηρούμε ότι το αποτέλεσμα είναι ικανοποιητικό στην πρώτη και στην δεύτερη φωτογραφία και σχεδόν τέλειο στην τελευταία. 

Το αρχείο [![c.py](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/c/c.py)](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/c/c.py) είναι όπως στα προηγούμενα ερωτήματα της μορφής: 
```
python3 c.py <input filename> <output filename>
```
Εκτελώντας `python3 c.py image5.jpg kmeans5.jpg` αποθηκεύει τοπικά και βγάζει στον χρήστη αποτέλεσμα:
![kmeans5.jpg](https://github.com/dip-course/teliki-askisi-me-tensorflow-terrys48/blob/master/c/kmeans5.jpg)

# ΕΠΙΛΟΓΟΣ
Στο ερώτημα τρία όπως θα δείτε και στον κώδικα προσπάθησα να βελτιώσω το αποτέλεσμα του kmeans για ομαδοποίηση με διάφορα τεχνάσματα στο σύνολο δεδομένων όπως για παράδειγμα να κανονικοποιήσω τα δεδομένα πριν την υλοποίηση του kmeans, πράγμα που έμαθα στο μάθημα "Αναγνώριση Προτύπων" του προηγούμενου εξαμήνου, επίσης και τον τρόπο λειτουργίας της μεθόδου PCΑ, [![εδώ](https://github.com/terrys48/pattern_recognition)](https://github.com/terrys48/pattern_recognition) μπορείτε να δείτε κάποια αποτελέσματα διαφορετικών μεθόδων σε μεγάλα σύνολα δεδομένων. Καμία από αυτές τις ενέργειες δεν έφεραν καλύτερο αποτέλεσμα από το αρχικό.

Ευχαριστώ πολύ, καλό υπόλοιπο καλοκαιριού.

*Η παράδωση στο αποθετήριο πραγματοποιήθηκε κατά την πρώτη φάση της προθεσμίας (πριν τις 22.07.2020).*
